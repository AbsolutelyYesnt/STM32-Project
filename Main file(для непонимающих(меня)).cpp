#include "stm32f1xx_hal.h" // Подключаем библиотеку для микроконтроллера STM32F103C8T6
#include "mcp23017.h" // Подключаем библиотеку для работы с MCP23017
#include "socket.h" // библиотека для W5500
#include "network_settings.h" // Подключение настроек сети

#define MY_PORT 5000 // Порт сервера

uint8_t buffer[1024]; // Буфер для приема данных

I2C_HandleTypeDef hi2c1; // Объявляем структуру для работы с интерфейсом I2C

void MX_I2C1_Init(void)
{
  hi2c1.Instance = I2C1; // Указываем, что используем первый I2C интерфейс
  hi2c1.Init.ClockSpeed = 400000; // Устанавливаем скорость передачи данных 400 кбит/с
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2; /*коэффициент заполнения в интерфейсе I2C определяет, 
  как долго сигнал на линии SCL(Serial Clock) будет находиться в состоянии "высокого" уровня (1) и "низкого" уровня (0) во временном отрезке, который обозначается как один тактовый период.
  Например, коэффициент заполнения 2 означает, что сигнал будет находиться в состоянии "высокого" уровня в течение двух третей тактового периода, 
  а в состоянии "низкого" уровня - в течение одной трети тактового периода.*/
  hi2c1.Init.OwnAddress1 = 0;/*Устанавливаем собственный адрес устройства 1 (не используется) В данном коде установка собственного адреса устройства не используется, 
  вероятно, потому что наш микроконтроллер является главным устройством на шине I2C и не будет идентифицироваться другими устройствами по адресу, 
  а, скорее, будет использовать адреса подключенных устройств для общения с ними*/
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT; // Устанавливаем 7-битный режим адресации
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE; // Отключаем двойной режим адресации
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE; // Отключаем режим общего вызова
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE; // Отключаем режим "нестандартная задержка"
  if (HAL_I2C_Init(&hi2c1) != HAL_OK) // Инициализируем I2C интерфейс и проверяем успешность операции
  {
    Error_Handler(); // Обработка ошибки инициализации
  }
}

void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0}; // Объявляем структуру для инициализации портов ввода/вывода (GPIO)
  
  __HAL_RCC_GPIOB_CLK_ENABLE(); /*Включаем тактирование порта B. Микроконтроллеры STM32 имеют различные периферийные устройства и порты ввода/вывода (GPIO), 
  которые нуждаются в тактовом сигнале, чтобы работать. Этот макрос включает тактовый сигнал для порта B, что позволяет этому порту функционировать правильно.
  Когда тактирование порта B включено, мы можем использовать его для управления подключенными к нему периферийными устройствами, такими как сенсоры, светодиоды, кнопки и т. д.*/ 
  
  // Настраиваем пины порта B для работы в режиме альтернативной функции с открытым коллектором (для I2C)
  GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_7; // Пины I2C SCL и SDA. Здесь мы указываем, что пины порта B, которые будут использоваться для интерфейса I2C (SCL и SDA), это пины 6 и 7.
  GPIO_InitStruct.Mode = GPIO_MODE_AF_OD; /*Режим альтернативной функции с открытым коллектором Мы устанавливаем режим работы этих пинов как альтернативную функцию с открытым коллектором. 
  Это означает, что пины будут использоваться не для обычных цифровых сигналов, а для работы с альтернативной функцией, 
  в данном случае - для работы с интерфейсом I2C. Открытый коллектор означает, что устройство подключается к пину как "дырка" в коллекторе транзистора, 
  позволяя множеству устройств подключаться к этому же пину.*/ 
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; /*Здесь мы устанавливаем высокую скорость работы порта, что означает, 
  что пины будут работать на максимальной скорости для поддержки I2C с высокой скоростью передачи данных.*/ 
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct); // Эта строка применяет все наши настройки к порту B, чтобы заданные пины (6 и 7) работали в соответствии с нашими требованиями для интерфейса I2C.
}

void init_MCP23017(void)
{
  uint8_t address[] = {0x20, 0x21, 0x22, 0x23, 0x24}; // Задаем адреса пяти расширителей MCP23017
  uint8_t gpio_direction = 0x00; // Задаем направление всех пинов - на выход
  uint8_t pull_ups = 0xFF; /*Включаем подтягивающие резисторы на всех пинах. Когда подтягивающие резисторы включены, пины будут иметь высокий уровень напряжения (логическую "1"), 
  если на них не подключено ничего другого.*/ 
  
  // Инициализируем каждый из пяти расширителей MCP23017
  for(int i = 0; i < 5; i++) {
      mcp23017_init(&hi2c1, address[i], gpio_direction, pull_ups); // Инициализация расширителя с заданными параметрами
  }
}

void toggle_MCP23017_pin(uint8_t address, uint8_t pin)
{
    // Функция для переключения состояния пина MCP23017
    mcp23017_write_pin(&hi2c1, address, pin, !mcp23017_read_pin(&hi2c1, address, pin)); // Чтение текущего состояния пина, инверсия и запись обратно
}

void init_ethernet(void)// Функция для инициализации Ethernet порта W5500
{
  
    // Инициализация SPI для взаимодействия с W5500
    SPI_init();

    // Настройка W5500
    W5500_init(); /*это функции инициализации SPI и W5500, 
    которые должны быть реализованы в вашем драйвере W5500. set_network_settings() - это функция, 
    которая устанавливает параметры сети, такие как IP-адрес, маска подсети и шлюз.*/

    // Установка параметров сети
    set_network_settings(IP_ADDRESS, SUBNET_MASK, GATEWAY);//Изменить значения 

    // Запуск Ethernet порта
    Ethernet_start(); //это функция, которая запускает Ethernet порт для начала обмена данными по сети.
}

int main(void)
{
  HAL_Init(); // Инициализация HAL (Hardware Abstraction Layer) для работы с микроконтроллером
  MX_GPIO_Init(); // Вызов функции инициализации портов GPIO
  MX_I2C1_Init(); // Вызов функции инициализации I2C интерфейса
  
  init_MCP23017(); // Вызов функции инициализации расширителей ввода/вывода MCP23017
  
  init_ethernet(); // Вызов функции инициализации Ethernet порта

  // Переменные для работы с сокетом
  int32_t ret; // Переменная для хранения возвращаемых значений функций
  uint8_t sock = 0; // Переменная для номера сокета (связана с сетевым портом)
  
  // Инициализация сокета для прослушивания входящих соединений
  socket(sock, Sn_MR_TCP, MY_PORT, 0);

  while (1) // Бесконечный цикл
  { 
    // Принятие входящего соединения
    if ((ret = listen(sock)) != SOCK_OK) {
      continue; // Продолжение цикла, если принятие соединения не удалось
    }

    // Получение данных
    if ((ret = recv(sock, buffer, sizeof(buffer))) <= 0) {
      continue; // Продолжение цикла, если прием данных не удался
    }

    // Обработка полученных данных
    // Предполагается, что данные содержат номер пина MCP23017 для переключения
    uint8_t pin_to_toggle = buffer[0] - '0'; // Преобразование символа в число
    toggle_MCP23017_pin(0x20, pin_to_toggle); // Вызов функции для переключения состояния пина MCP23017

    // Отправка подтверждения
    send(sock, buffer, ret); // Отправка обратно принятых данных 
    /*sock: Это переменная, которая используется для идентификации сокета (соединения) в программе. 
    В контексте этого кода, переменная sock используется для управления сетевым соединением с помощью W5500. 
    В данном случае, sock - это номер сокета, который ассоциирован с определенным сетевым портом и используется для управления соединением по протоколу TCP/IP.
    buffer: Это массив, который используется для хранения данных. 
    В данном коде, buffer используется для приема и отправки данных через Ethernet порт W5500. 
    Для удобства, в этом коде buffer имеет размер 1024 байта, что позволяет ему хранить достаточное количество данных.
    ret: Это переменная, которая используется для хранения возвращаемых значений функций. 
    В данном контексте, ret обычно содержит код возврата, возвращаемый функциями, которые работают с сетевым соединением или с данными. 
    Например, если функция recv успешно принимает данные, она вернет количество принятых байтов, а если происходит ошибка, она может вернуть соответствующий код ошибки. 
    Переменная ret используется для проверки этих значений и принятия соответствующих действий в программе.*/

    /* Переключаем каждый пин на всех расширителях ввода/вывода (кусок кода для проверки)
    for(int i = 0; i < 5; i++) { // Цикл по каждому расширителю
        for(int j = 0; j < 16; j++) { // Цикл по каждому пину на расширителе
            toggle_MCP23017_pin(0x20 + i, j); // Вызов функции для переключения состояния пина MCP23017
            HAL_Delay(500); // Задержка в 500 мс
        }
    }*/
  }
}